package comprehend

import java.nio.file.Paths

import org.json4s._
import org.json4s.native.JsonMethods._
import com.amazonaws.services.lambda.runtime.{Context, RequestHandler}
import com.amazonaws.services.lambda.runtime.events.ScheduledEvent
import software.amazon.awssdk.services.comprehend.ComprehendClient
import software.amazon.awssdk.services.comprehend.model.{DetectKeyPhrasesRequest, DetectSentimentRequest}
import software.amazon.awssdk.services.dynamodb.DynamoDbClient
import software.amazon.awssdk.services.dynamodb.model.{AttributeValue, PutItemRequest}
import software.amazon.awssdk.services.s3.S3Client
import software.amazon.awssdk.services.s3.model.GetObjectRequest
import software.amazon.awssdk.services.transcribe.TranscribeClient
import software.amazon.awssdk.services.transcribe.model.GetTranscriptionJobRequest

import scala.io.Source
import scala.jdk.CollectionConverters._

/**
 * Class used to process CloudWatch events after Transcribe Finishes processing a job.
 */
class App extends RequestHandler[ScheduledEvent, String] {
  /** Name of the bucket containing the data. */
  val bucketName: String = sys.env.getOrElse("BUCKET_NAME", "transcribe-sentiment-poc")
  /** Comprehend client. */
  val comprehendClient: ComprehendClient = ComprehendClient.builder().build()
  /** Client for DynamoDb. */
  val dynamoDbClient: DynamoDbClient = DynamoDbClient.builder().build()
  /** Code for the language to use in Comprehend. */
  val languageCode: String = sys.env.getOrElse("LANGUAGE_CODE", "es")
  /** The S3 client. */
  val s3Client: S3Client = S3Client.builder().build()
  /** DynamoDB process status table. */
  val tableName: String = sys.env.getOrElse("TABLE_NAME", "transcribe-sentiment-poc-table")
  /** Client for Transcribe service. */
  val transcribeClient: TranscribeClient = TranscribeClient.builder().build()

  /**
   * Process the EventBridge event generated by Amazon Transcribe when the process finishes or fails.
   *
   * @param input with the event.
   * @param context of the execution.
   * @return The result.
   */
  override def handleRequest(input: ScheduledEvent, context: Context): String = {
    val logger = context.getLogger
    val jobId = input.getDetail.get("TranscriptionJobName").toString
    val status = input.getDetail.get("TranscriptionJobStatus").toString
    val time = input.getTime.toInstant.getMillis
    val item = Map.newBuilder[String, AttributeValue]
    item += "id" -> AttributeValue.builder().s(jobId).build()
    item += "transcribe" -> AttributeValue.builder().n(time.toString).build()
    item += "status" -> AttributeValue.builder().s(status).build()
    logger.log(s"JobId: ${jobId}, Status: ${status}")
    if ("COMPLETED" == status) {
      val request = GetTranscriptionJobRequest.builder()
        .transcriptionJobName(jobId)
        .build()
      val response = transcribeClient.getTranscriptionJob(request)
      println(response.toString)
      item += "transcribe" -> AttributeValue.builder()
        .n(response.transcriptionJob().completionTime().toEpochMilli.toString)
        .build()
      val transcriptLocation = response.transcriptionJob().transcript().transcriptFileUri()
      val transcriptText = processTranscript(jobId)
      val detectSentimentRequest = DetectSentimentRequest.builder()
        .languageCode(languageCode)
        .text(transcriptText)
        .build()
      val detectSentimentResponse = comprehendClient.detectSentiment(detectSentimentRequest)
      item += "sentiment" -> AttributeValue.builder().s(detectSentimentResponse.sentimentAsString()).build()
      val detectKeyPhrasesRequest = DetectKeyPhrasesRequest.builder()
        .languageCode(languageCode)
        .text(transcriptText)
        .build()
      val detectKeyPhrasesResponse = comprehendClient.detectKeyPhrases(detectKeyPhrasesRequest)
      item += "key_phrases" -> AttributeValue.builder().ss(detectKeyPhrasesResponse.keyPhrases()
        .asScala.map(keyPhrase => keyPhrase.toString).asJava).build()
    }
    val putItemRequest = PutItemRequest.builder()
      .item(item.result().asJava)
      .tableName(tableName)
      .build()
    dynamoDbClient.putItem(putItemRequest)
    "Ok"
  }

  private [this] def processTranscript(jobId: String): String = {
    val getObjectRequest = GetObjectRequest.builder()
      .bucket(bucketName)
      .key(s"${jobId}.json")
      .build()
    val tempFile = Paths.get(sys.env.getOrElse("java.io.tmpdir", "/tmp"), s"${jobId}.json")
    val getObjectResponse = s3Client.getObject(getObjectRequest, tempFile)
    val transcript = parse(Source.fromFile(tempFile.toFile).reader())
    val text = (transcript \ "results" \ "transcripts")(0) \ "transcript"
    println(text)
    compact(render(text))
  }
}
