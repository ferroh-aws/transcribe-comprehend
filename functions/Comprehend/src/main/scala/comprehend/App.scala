package comprehend

import java.io.{File, FileOutputStream}
import java.nio.file.Paths
import java.util.Date

import org.json4s._
import org.json4s.jackson.JsonMethods._
import org.json4s.jackson.Serialization
import org.json4s.jackson.Serialization.write
import com.amazonaws.services.lambda.runtime.{Context, RequestHandler}
import com.amazonaws.services.lambda.runtime.events.ScheduledEvent
import software.amazon.awssdk.services.comprehend.ComprehendClient
import software.amazon.awssdk.services.comprehend.model.{DetectKeyPhrasesRequest, DetectSentimentRequest}
import software.amazon.awssdk.services.dynamodb.DynamoDbClient
import software.amazon.awssdk.services.dynamodb.model.{AttributeAction, AttributeValue, AttributeValueUpdate, UpdateItemRequest}
import software.amazon.awssdk.services.s3.S3Client
import software.amazon.awssdk.services.s3.model.{GetObjectRequest, PutObjectRequest}
import software.amazon.awssdk.services.transcribe.TranscribeClient
import software.amazon.awssdk.services.transcribe.model.GetTranscriptionJobRequest

import scala.io.Source
import scala.jdk.CollectionConverters._

/**
 * Class used to process CloudWatch events after Transcribe Finishes processing a job.
 */
class App extends RequestHandler[ScheduledEvent, String] {
  /** Prefix used to store the analytics JSON files. */
  val bucketAnalyticsPrefix: String = "analytics/"
  /** Name of the bucket containing the data. */
  val bucketName: String = sys.env.getOrElse("BUCKET_NAME", "transcribe-sentiment-poc")
  /** Comprehend client. */
  val comprehendClient: ComprehendClient = ComprehendClient.builder().build()
  /** Client for DynamoDb. */
  val dynamoDbClient: DynamoDbClient = DynamoDbClient.builder().build()
  /** Code for the language to use in Comprehend. */
  val languageCode: String = sys.env.getOrElse("LANGUAGE_CODE", "es")
  /** The S3 client. */
  val s3Client: S3Client = S3Client.builder().build()
  /** DynamoDB process status table. */
  val tableName: String = sys.env.getOrElse("TABLE_NAME", "transcribe-sentiment-poc-table")
  /** Client for Transcribe service. */
  val transcribeClient: TranscribeClient = TranscribeClient.builder().build()
  /** Formats used for JSON Serialization. */
  implicit val formats: Formats = Serialization.formats(NoTypeHints)

  /**
   * Process the EventBridge event generated by Amazon Transcribe when the process finishes or fails.
   *
   * @param input with the event.
   * @param context of the execution.
   * @return The result.
   */
  override def handleRequest(input: ScheduledEvent, context: Context): String = {
    val logger = context.getLogger
    val jobId = input.getDetail.get("TranscriptionJobName").toString
    val status = input.getDetail.get("TranscriptionJobStatus").toString
    val time = input.getTime.toInstant.getMillis
    val key = Map.newBuilder[String, AttributeValue]
    key += "id" -> AttributeValue.builder().s(jobId).build()
    val item = Map.newBuilder[String, AttributeValueUpdate]
    item += "transcribe" -> AttributeValueUpdate.builder()
      .action(AttributeAction.PUT)
      .value(AttributeValue.builder()
        .n(time.toString)
        .build())
      .build()
    item += "status" -> AttributeValueUpdate.builder()
      .action(AttributeAction.PUT)
      .value(AttributeValue.builder().s(status).build())
      .build()
    logger.log(s"JobId: $jobId, Status: $status")
    if ("COMPLETED" == status) {
      val request = GetTranscriptionJobRequest.builder()
        .transcriptionJobName(jobId)
        .build()
      val response = transcribeClient.getTranscriptionJob(request)
      println(response.toString)
      item += "transcribe" -> AttributeValueUpdate.builder()
        .action(AttributeAction.PUT)
        .value(AttributeValue.builder()
          .n(response.transcriptionJob().completionTime().toEpochMilli.toString)
          .build())
        .build()
      response.transcriptionJob().transcript().transcriptFileUri()
      val transcriptText = processTranscript(jobId)
      val detectSentimentRequest = DetectSentimentRequest.builder()
        .languageCode(languageCode)
        .text(transcriptText)
        .build()
      val detectSentimentResponse = comprehendClient.detectSentiment(detectSentimentRequest)
      item += "sentiment" -> AttributeValueUpdate.builder()
        .action(AttributeAction.PUT)
        .value(AttributeValue.builder().s(detectSentimentResponse.sentimentAsString()).build())
        .build()
      val detectKeyPhrasesRequest = DetectKeyPhrasesRequest.builder()
        .languageCode(languageCode)
        .text(transcriptText)
        .build()
      val detectKeyPhrasesResponse = comprehendClient.detectKeyPhrases(detectKeyPhrasesRequest)
      item += "key_phrases" -> AttributeValueUpdate.builder()
        .action(AttributeAction.PUT)
        .value(AttributeValue.builder().ss(detectKeyPhrasesResponse.keyPhrases()
          .asScala.map(keyPhrase => keyPhrase.toString).asJava).build())
        .build()
      val keyPhrases = detectKeyPhrasesResponse.keyPhrases()
        .asScala
        .map(keyPhrase => KeyPhrase(keyPhrase.score(), keyPhrase.text()))
        .toList
      val outcome = ComprehendOutcome(jobId, new Date(time), status, detectSentimentResponse.sentiment().toString,
        keyPhrases)
      val tempFile = File.createTempFile("temp-", "json")
      val outputStream = new FileOutputStream(tempFile)
      write(outcome, outputStream)
      outputStream.flush()
      outputStream.close()
      val putObjectRequest = PutObjectRequest.builder()
        .bucket(bucketName)
        .contentType("application/json")
        .key(s"$bucketAnalyticsPrefix$jobId.json")
        .build()
      val putObjectResponse = s3Client.putObject(putObjectRequest, tempFile.toPath)
      logger.log(putObjectResponse.toString)
    }
    val updateItemRequest = UpdateItemRequest.builder()
      .attributeUpdates(item.result().asJava)
      .key(key.result.asJava)
      .tableName(tableName)
      .build()
    dynamoDbClient.updateItem(updateItemRequest)
    "Ok"
  }

  private [this] def processTranscript(jobId: String): String = {
    val getObjectRequest = GetObjectRequest.builder()
      .bucket(bucketName)
      .key(s"$jobId.json")
      .build()
    val tempFile = Paths.get(sys.env.getOrElse("java.io.tmpdir", "/tmp"), s"$jobId.json")
    s3Client.getObject(getObjectRequest, tempFile)
    val transcript = parse(Source.fromFile(tempFile.toFile).reader())
    val text = (transcript \ "results" \ "transcripts")(0) \ "transcript"
    compact(render(text))
  }

  /**
   * Case class used to export the results of the comprehend job to S3 as JSON.
   *
   * @param id of the process.
   * @param date of the process.
   * @param status of the process.
   * @param sentiment detected on the transcription.
   * @param keyPhrases in the transcribed document.
   */
  sealed case class ComprehendOutcome(id: String, date: Date, status: String, sentiment: String,
                                      keyPhrases: List[KeyPhrase])

  /**
   * Case class used to store a key phrase.
   *
   * @param score of the key phrase.
   * @param text of the actual key phrase.
   */
  sealed case class KeyPhrase(score: Float, text: String)
}
